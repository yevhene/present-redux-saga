<section>
  <h1>Redux Saga</h1>

  <small>
    Yevhen Shemet<br />
    github: <a target="_blank" href="https://github.com/yevhene/present-redux-saga">yevhene/present-redux-saga</a>
  </small>
</section>

<section>
  <h2>Поняття</h2>

  <section>
    <h2>Паралелізм (Parallelism)</h2>

    <p>Коли декілька задач можуть виконуватись повністю одночасно. (Наприклад: на багатоядерному процессорі)</p>
  </section>

  <section>
    <h2>Конкуренція (Concurrency)</h2>

    <p>Коли декілька задач можуть виконуватись у різні проміжки часу, що можуть перемішуватись між собою. Вони можуть перекриватись або ні.</p>
  </section>
</section>

<section>
  <h2>Ітератори</h2>

  <section>
    <pre><code class="hljs" data-trim>
const array = [1, 2, 3];

// Ітеруюча функція
const newIterator = array[Symbol.iterator];

// Створення нового ітератора
const iterator = newIterator();

// Розгортування ітератора
iterator.next() //=&gt; {value: 1, done: false}
iterator.next() //=&gt; {value: 2, done: false}
iterator.next() //=&gt; {value: 3, done: false}
iterator.next() //=&gt; {value: undefined, done: true}
    </code></pre>
  </section>

  <section>
    <h3>Конкуруючі ітератори</h3>

    <pre><code class="hljs" data-trim>
const array = [1, 2, 3];
const newIterator = array[Symbol.iterator];

const iterator = newIterator();
iterator.next() //=&gt; {value: 1, done: false}
iterator.next() //=&gt; {value: 2, done: false}
iterator.next() //=&gt; {value: 3, done: false}
iterator.next() //=&gt; {value: undefined, done: true}

const iterator1 = newIterator();
iterator1.next() //=&gt; {value: 1, done: false}
    </code></pre>
  </section>

  <section>
    <h3>Створення ітеруючої функції</h3>

    <pre><code class="hljs" data-trim>
const obj = {};
obj[Symbol.iterator] = function() {
  return {
    counter: 0,
    done: false,
    next: function() {
      if (this.counter &lt; 3) {
        this.counter++;
        return { value: this.counter };
      } else {
        return { done: true };
      }
    }
  };
};
    </code></pre>
  </section>

  <section>
    <h3>for..of</h3>

    <pre><code class="hljs" data-trim>
for (let e of obj) {
  console.log(e);
}
//&gt; 1
//&gt; 2
//&gt; 3
    </code></pre>

    <p>Приймає будь-який об'єкт у якого є властивість <i>Symbol.iterator</i>.</p>
  </section>

  <section>
    <h3>spread (...)</h3>

    <pre><code class="hljs" data-trim>
[...obj]; //=&gt; [1, 2, 3]
    </code></pre>

    <p>Приймає будь-який об'єкт у якого є властивість <i>Symbol.iterator</i>.</p>
  </section>

  <section>
    <h3>Протоколи Ітераторів</h3>

    <pre><code class="hljs" data-trim>
interface Iterable {
  [Symbol.iterator]() : Iterator;
}
interface Iterator {
  next() : IteratorResult;
  return?(value? : any) : IteratorResult;
}
interface IteratorResult {
  value : any;
  done : boolean;
}
    </code></pre>

    <p>Iterator зазвичай також реалізує Iterable і повертає себе.</p>
  </section>
</section>

<section>
  <h2>Генератори</h2>

  <section>
    <h3>Генеруюча функція</h3>

    <pre><code class="hljs" data-trim>
function *seq() {
  let n = 1;
  yield n++;
  yield n++;
}
    </code></pre>
  </section>

  <section>
    <h3>Генерація значень</h3>

    <pre><code class="hljs" data-trim>
function *seq() {
  let n = 1;
  yield n++;
  yield n++;
}

const a = seq(); //=&gt; Об'єкт генератор (похідний від Iterator)
a.next(); //=&gt; {value: 1, done: false}
a.next(); //=&gt; {value: 2, done: false}
a.next(); //=&gt; {value: undefined, done: true}
    </code></pre>
  </section>

  <section>
    <h3>Конкуруючі генератори</h3>

    <pre><code class="hljs" data-trim>
function *seq() {
  let n = 1;
  yield n++;
  yield n++;
}

const a = seq(); //=&gt; Об'єкт генератор (похідний від Iterator)
const b = seq(); //=&gt; Об'єкт генератор (похідний від Iterator)
a.next(); //=&gt; {value: 1, done: false}
a.next(); //=&gt; {value: 2, done: false}
b.next(); //=&gt; {value: 1, done: false}
a.next(); //=&gt; {value: undefined, done: true}
    </code></pre>
  </section>

  <section>
    <h3>Вкладені ітеровані значення</h3>

    <pre><code class="hljs" data-trim>
function *neg() {
  yield -1;
  yield -2;
}

function *seq() {
  yield* neg();
  yield* [1, 2];
}

const a = seq(); //=&gt; Об'єкт генератор
a.next(); //=&gt; {value: -1, done: false}
a.next(); //=&gt; {value: -2, done: false}
a.next(); //=&gt; {value: 1, done: false}
a.next(); //=&gt; {value: 2, done: false}
a.next(); //=&gt; {value: undefined, done: true}
    </code></pre>
  </section>

  <section>
    <h3>Кінцева генерація значень</h3>

    <pre><code class="hljs" data-trim>
function *seq() {
  let n = 1;
  yield n++;
  yield n++;
  return n;
}

const a = seq(); //=&gt; Об'єкт генератор
a.next(); //=&gt; {value: 1, done: false}
a.next(); //=&gt; {value: 2, done: false}
a.next(); //=&gt; {value: 3, done: true}
a.next(); //=&gt; {value: undefined, done: true}
    </code></pre>
  </section>

  <section>
    <h3>Генератор це ітератор</h3>

    <pre><code class="hljs" data-trim>
function *seq() {
  let n = 1;
  yield n++;
  yield n++;
  return n;
}

[...seq()] //=&gt; [1, 2]
    </code></pre>

    <p>Останнє значення не попадає в ітерацію тому що поряд із ним <i>done: true</i><p>
  </section>

  <section>
    <h3>Підстановка значень</h3>

    <pre><code class="hljs" data-trim>
function *seq(n = 1) {
  while (true) {
    n += (yield n) || 1;
  }
}

const a = seq(17); //=&gt; Об'єкт генератор
a.next(/* все одно */); //=&gt; {value: 17, done: false}
a.next(); //=&gt; {value: 18, done: false}
a.next(8); //=&gt; {value: 26, done: false}
a.next(); //=&gt; {value: 27, done: false}
    </code></pre>
  </section>

  <section>
    <h3>Підстановка значень для повернення</h3>

    <pre><code class="hljs" data-trim>
function *seq(n = 1) {
  while (true) {
    n += (yield n) || 1;
  }
}

const a = seq(17); //=&gt; Об'єкт генератор
a.next(/* все одно */); //=&gt; {value: 17, done: false}
a.next(); //=&gt; {value: 18, done: false}
a.next(8); //=&gt; {value: 26, done: false}
a.next(); //=&gt; {value: 27, done: false}
a.return(7) //=&gt; {value: 7, done: true}
    </code></pre>
  </section>

  <section>
    <h3>Підстановка помилок</h3>

    <pre><code class="hljs" data-trim>
function *seq(n) {
  try {
    yield n;
  } catch (e) {
    yield e;
  }
}

const a = seq(17); // =&gt; Об'єкт генератор
a.next(); // =&gt; {value: 17, done: false}
a.throw(4); // =&gt; {value: 4, done: false}
a.next(); // =&gt; {value: undefined, done: true}
    </code></pre>
  </section>

  <section>
    <h3>Протоколи Генераторів</h3>

    <pre><code class="hljs" data-trim>
interface Generator : extends Iterator {
    throw(value? : any) : IteratorResult;
}
    </code></pre>

    <pre><code class="hljs" data-trim>
interface Iterable {
  [Symbol.iterator]() : Iterator;
}
interface Iterator extends Iterable {
  next() : IteratorResult;
  return?(value? : any) : IteratorResult;
}
interface IteratorResult {
    value : any;
    done : boolean;
}
    </code></pre>
  </section>

  <section>
    <h3>Виконувач (Runner)</h3>

    <ul>
      <li>Розгортає генератор до кінця;</li>
      <li>Якщо генерується просте значення просто повертає його в генератор;</li>
      <li>Якщо генерується функція, вона виконується, результат розгортується до простого значення і повертається назад;</li>
      <li>Якщо генерується обіцянка, очікується на її вирішення, підставляється або значення або помилка (обіцянка розгортується сама за визначенням);</li>
      <li>Якщо генерується інший генератор, він розгортується за тими ж правилами.</li>
    </ul>
  </section>

  <section>
    <h3>co</h3>

    <pre><code class="hljs" data-trim>
co(seq())
  .then(function(value) {
    console.log(`Результат: ${value}`);
  })
  .catch(function(err) {
    console.error(`Помилка: ${err.toString()}`);
  });
    </code></pre>
  </section>

  <section>
    <h3>Приклад</h3>

    <pre><code class="hljs" data-trim>
function *userAddress(req, res) {
  const user = yield User.findById(req.userId);
  const address = yield Address.findById(user.addressId);

  const html = yield jade.renderFile('address.jade', { address }));
  res.send(html);
}
    </code></pre>
  </section>

  <section>
    <h3>Розширений приклад</h3>

    <pre><code class="hljs" data-trim>
function *placesNearby(req, res) {
  const user = yield User.findById(req.userId);
  const address = yield Address.findById(user.addressId);

  const [users, places] = yield Promise.all([
    User.near(address).findAll(),
    Place.near(address).findAll()
  ]));

  const html = yield jade.renderFile('address.jade', {
    address, users, places
  }));
  res.send(html);
}
    </code></pre>
  </section>

  <section>
    <h3>Розширений приклад з обробкою помилок</h3>

    <pre><code class="hljs" data-trim>
function *placesNearbyOrError(req, res) {
  try {
    const user = yield User.findById(req.userId);
    const address = yield Address.findById(user.addressId);
    const [users, places] = yield Promise.all([
      User.near(address).findAll(),
      Place.near(address).findAll()
    ]))

    const html = yield jade.renderFile('address.jade', {
      address, users, places
    }));
    res.send(html));
  } catch (e) {
    res.send('Error' + err.toString()));
  }
}
    </code></pre>
  </section>

  <section>
    <h3>Переваги/Недоліки</h3>

    <ul>
      <li>+ Всі бонуси обіцянок</li>
      <li>+ Природний хід виконання</li>
      <li>+ Знову можна використовувати try-catch</li>
      <li>- Це сложна</li>
      <li>- Це хак</li>
      <li>- Необхідна спеціальна функція - виконувач</li>
    </ul>
  </section>
</section>

<section>
  <h2>В старих браузерах</h2>

  <section>
    <h3>Транспіляція (Babel)</h3>

    <pre><code class="hljs" data-trim>
function *seq() {
  let n = yield 17;
  yield 18 + n;
}
    </code></pre>
  </section>

  <section>
    <h3>Транспіляція (Babel)</h3>

    <pre><code class="hljs" data-trim>
"use strict";

var _marked = [seq].map(regeneratorRuntime.mark);

function seq() {
  var n;
  return regeneratorRuntime.wrap(function seq$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return 17;

        case 2:
          n = _context.sent;
          _context.next = 5;
          return 18 + n;

        case 5:
        case "end":
          return _context.stop();
      }
    }
  }, _marked[0], this);
}
    </code></pre>
  </section>
</section>

<section>
  <h2>Асинхронні функції</h2>

  <section>
    <h3>Приклад</h3>

    <pre><code class="hljs" data-trim>
async function userAddress(req, res) {
  const user = await User.findById(req.userId);
  const address = await Address.findById(user.addressId);

  const html = await jade.renderFile('address.jade', { address }));
  res.send(html));
}
    </code></pre>
  </section>

  <section>
    <h3>Використання</h3>

    <pre><code class="hljs" data-trim>
userAddress(req, res)
  .then(/*...*/)
    </code></pre>
  </section>

  <section>
    <h3>Більше прикладів</h3>

    <pre><code class="hljs" data-trim>
function resolveAfter2Seconds(x) {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(x);
    }, 2000);
  });
}
    </code></pre>
  </section>

  <section>
    <h3>Послідовно</h3>

    <pre><code class="hljs" data-trim>
async function add2(x) {
  var a = await resolveAfter2Seconds(20);
  var b = await resolveAfter2Seconds(30);
  return x + a + b;
}

add2(10).then(v =&gt; {
  console.log(v);  // prints 60 after 4 seconds.
});
    </code></pre>
  </section>

  <section>
    <h3>Паралельно</h3>

    <pre><code class="hljs" data-trim>
async function add1(x) {
  var a = resolveAfter2Seconds(20);
  var b = resolveAfter2Seconds(30);
  return x + await a + await b;
}

add1(10).then(v =&gt; {
  console.log(v);  // prints 60 after 2 seconds.
});
    </code></pre>
  </section>

  <section>
    <h3>Переваги/Недоліки</h3>

    <ul>
      <li>+ Всі бонуси генераторів і обіцянок</li>
      <li>+ Підтримка на рівні мови</li>
      <li>- Важкі в тестуванні</li>
    </ul>
  </section>
</section>

<section>
  <h2>Асинхронна ітерація<small>ES2018</small></h2>

  <section>
    <h3>Приклад завантаження</h3>

    <pre><code class="hljs" data-trim>
async function getResponseSize(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  let total = 0;

  while (true) {
    const {done, value} = await reader.read();
    if (done) return total;
    total += value.length;
  }
}
    </code></pre>
  </section>

  <section>
    <h3>Асинхронний ітератор</h3>

    <pre><code class="hljs" data-trim>
async function example() {
  // Regular iterator:
  const iterator = createNumberIterator();
  iterator.next(); // Object {value: 1, done: false}
  iterator.next(); // Object {value: 2, done: false}
  iterator.next(); // Object {value: 3, done: false}
  iterator.next(); // Object {value: undefined, done: true}

  // Async iterator:
  const asyncIterator = createAsyncNumberIterator();
  const p = asyncIterator.next(); // Promise
  await p;                    // Object {value: 1, done: false}
  await asyncIterator.next(); // Object {value: 2, done: false}
  await asyncIterator.next(); // Object {value: 3, done: false}
  await asyncIterator.next(); // Object {value: undefined, done: true}
}
    </code></pre>
  </section>

  <section>
    <h3>Асинхронний цикл</h3>

    <pre><code class="hljs" data-trim>
async function example() {
  // Regular iterator:
  for (const item of thing) {
    // …
  }

  // Async iterator:
  for await (const item of asyncThing) {
    // …
  }
}
    </code></pre>
  </section>

  <section>
    <h3>Асинхронний цикл</h3>

    <pre><code class="hljs" data-trim>
async function example() {
  const arrayOfFetchPromises = [
    fetch('1.txt'),
    fetch('2.txt'),
    fetch('3.txt')
  ];

  // Regular iterator:
  for (const item of arrayOfFetchPromises) {
    console.log(item); // Logs a promise
  }

  // Async iterator:
  for await (const item of arrayOfFetchPromises) {
    console.log(item); // Logs a response
  }
}
    </code></pre>
  </section>

  <section>
    <h3>Приклад асинхронної ітерації</h3>

    <pre><code class="hljs" data-trim>
async function getResponseSize(url) {
  const response = await fetch(url);
  let total = 0;

  for await (const chunk of response.body) {
    total += chunk.length;
  }
  return total;
}
    </code></pre>
  </section>

  <section>
    <h3>Протокол</h3>

    <pre><code class="hljs" data-trim>
interface AsyncIterable {
    [Symbol.asyncIterator]() : AsyncIterator;
}
interface AsyncIterator {
    next() : Promise<IteratorResult>;
}
interface IteratorResult {
    value: any;
    done: boolean;
}
    </code></pre>
  </section>

  <section>
    <h3>Створення асинхронного ітератора</h3>

    <pre><code class="hljs" data-trim>
// Note the * after "function"
async function* asyncRandomNumbers() {
  // This is a web service that returns a random number
  const url = 'https://www.random.org/decimal-fractions/?num=1&amp;dec=10&amp;col=1&format=plain&rnd=new';

  while (true) {
    const response = await fetch(url);
    const text = await response.text();
    yield Number(text);
  }
}
    </code></pre>
  </section>

  <section>
    <h3>Приклад роботи</h3>

    <pre><code class="hljs" data-trim>
async function example() {
  for await (const number of asyncRandomNumbers()) {
    console.log(number);
    if (number &gt; 0.95) break;
  }
}
    </code></pre>
  </section>
</section>

<section>
  <h2>Redux Saga</h2>

  <section>
    <h3>Middleware</h3>

    <pre><code class="hljs" data-trim>
import { createStore, applyMiddleware } from 'redux'
import createSagaMiddleware from 'redux-saga'

import reducer from './reducers'
import mySaga from './sagas'

const sagaMiddleware = createSagaMiddleware()

const store = createStore(
  reducer,
  applyMiddleware(sagaMiddleware)
)

sagaMiddleware.run(mySaga)
    </code></pre>
  </section>

  <section>
    <h3>take</h3>

    <pre><code class="hljs" data-trim>
import { take } from 'redux-saga/effects'

// FETCH_USERS
function* fetchUsers(action) { ... }

// use them in parallel
export default function* rootSaga() {
  while (true) {
    yield take('FETCH_USERS', fetchUsers)
  }
}
    </code></pre>

    <p>Waits for event</p>
  </section>


  <section>
    <h3>takeEvery</h3>

    <pre><code class="hljs" data-trim>
import { takeEvery } from 'redux-saga/effects'

// FETCH_USERS
function* fetchUsers(action) { ... }

// CREATE_USER
function* createUser(action) { ... }

// use them in parallel
export default function* rootSaga() {
  yield takeEvery('FETCH_USERS', fetchUsers)
  yield takeEvery('CREATE_USER', createUser)
}
    </code></pre>

    <p>Takes every event and executes in parallel</p>
  </section>

  <section>
    <h3>takeLatest</h3>

    <pre><code class="hljs" data-trim>
import { takeLatest } from 'redux-saga/effects'

// FETCH_USERS
function* fetchUsers(action) { ... }

// use them in parallel
export default function* rootSaga() {
  yield takeLatest('FETCH_USERS', fetchUsers)
}
    </code></pre>

    <p>Takes only latest event. If another event dispatched, previous cancelled</p>
  </section>

  <section>
    <h3>put</h3>

    <pre><code class="hljs" data-trim>
import { put } from 'redux-saga/effects'

function* fetchProducts() {
  const products = yield Api.fetch('/products')
  // create and yield a dispatch Effect
  yield put({ type: 'PRODUCTS_RECEIVED', products })
}
    </code></pre>

    <p>Dispatch action</p>
  </section>

  <section>
    <h3>call</h3>

    <pre><code class="hljs" data-trim>
import { call, put } from 'redux-saga/effects'

function* fetchProducts() {
  const products = yield call(Api.fetch, '/products')
  // create and yield a dispatch Effect
  yield put({ type: 'PRODUCTS_RECEIVED', products })
}
    </code></pre>

    <pre><code class="hljs" data-trim>
{
  CALL: {
    fn: Api.fetch,
    args: ['./products']
  }
}
    </code></pre>

    <p>Easier to test. Also has <code>apply</code> similar function</p>
  </section>

  <section>
    <h3>all</h3>

    <pre><code class="hljs" data-trim>
import { call, put, all } from 'redux-saga/effects'

function* fetchProducts() {
  const [users, repos] = yield all([
    call(fetch, '/users'),
    call(fetch, '/repos')
  ])

  yield put(...)
}
    </code></pre>

    <p>Runs in parallel</p>
  </section>

  <section>
    <h3>race</h3>

    <pre><code class="hljs" data-trim>
import { race, take, put } from 'redux-saga/effects'
import { delay } from 'redux-saga'

function* fetchPostsWithTimeout() {
  const {posts, timeout} = yield race({
    posts: call(fetchApi, '/posts'),
    timeout: call(delay, 1000)
  })

  if (posts)
    put({type: 'POSTS_RECEIVED', posts})
  else
    put({type: 'TIMEOUT_ERROR'})
}
    </code></pre>

    <p>Runs in parallel but waits only first</p>
  </section>

  <section>
    <h3>select</h3>

    <pre><code class="hljs" data-trim>
import { call, put, select } from 'redux-saga/effects'

function* fetchProducts() {
  const state = yield select()
  const products = yield call(Api.fetch, '/products', state.session.token)
  yield put({ type: 'PRODUCTS_RECEIVED', products })
}
    </code></pre>

    <p>Fetches redux state</p>
  </section>

  <section>
    <h3>Error handling</h3>

    <pre><code class="hljs" data-trim>
import { call, put, select } from 'redux-saga/effects'

function* fetchProducts() {
  try {
    const products = yield call(Api.fetch, '/products', state.session.token)
    yield put({ type: 'PRODUCTS_RECEIVED', products })
  } catch (e) {
    yield put({ type: 'PRODUCTS_ERROR', e })
  }
}
    </code></pre>
  </section>

  <section>
    <h3>fork</h3>

    <pre><code class="hljs" data-trim>
function* fetchAll() {
  const task1 = yield fork(fetchResource, 'users')
  const task2 = yield fork(fetchResource, 'comments')
  yield call(delay, 1000)
}

function* fetchResource(resource) {
  const { data } = yield call(api.fetch, resource)
  yield put(...)
}

function* main() {
  try {
    yield call(fetchAll)
  } catch (e) {
    // handle fetchAll errors
  }
}
    </code></pre>

    <p>Attached forks</p>
  </section>

  <section>
    <h3>spawn</h3>

    <p>Detached fork. Like another root saga</p>
  </section>

  <section>
    <h3>cancel</h3>

    <pre><code class="hljs" data-trim>
function* fetchAll() {
  const task1 = yield fork(fetchResource, 'users')
  yield call(delay, 1000)
  yield cancel(task1)
}

function* fetchResource(resource) {
  const { data } = yield call(api.fetch, resource)
  if (!(yield cancelled())) {
    yield put(...)
  }
}

function* main() {
  try {
    yield call(fetchAll)
  } catch (e) {
    // handle fetchAll errors
  }
}
    </code></pre>
  </section>

  <section>
    <h3>eventChannel</h3>

    <pre><code class="hljs" data-trim>
import { eventChannel, END } from 'redux-saga'

function countdown(secs) {
  return eventChannel(emitter =&gt; {
      const iv = setInterval(() =&gt; {
        secs -= 1
        if (secs &gt; 0) {
          emitter(secs)
        } else {
          // this causes the channel to close
          emitter(END)
        }
      }, 1000);
      // The subscriber must return an unsubscribe function
      return () =&gt; {
        clearInterval(iv)
      }
    }
  )
}
    </code></pre>
  </section>

  <section>
    <h3>channel</h3>

    <pre><code class="hljs" data-trim>
export function* saga() {
  const chan = yield call(countdown, value)
  try {
    while (true) {
      // take(END) will cause the saga to terminate by jumping to the finally block
      let seconds = yield take(chan)
      console.log(`countdown: ${seconds}`)
    }
  } finally {
    console.log('countdown terminated')
  }
}
    </code></pre>
  </section>
</section>

<section>
  <h2>Questions?</h2>
</section>
